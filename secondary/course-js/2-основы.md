# Основы языка


## Кодировка
Вжно чтоб кодировка страницы и кода скрипта совпадали.
- файл с кодом дложнеи иметь кодировку `utf-8`
- на странице должен быть мета-тэг с указанием кодировки `<meta charset='utf-8'>`
Остальные кодировки создают лишние проблемы.


## Вставка кода скрипта
- в теле документа
	```
	<script>
		alert( 'Привет, Мир!' );
	</script>
	```
- в подключаемом файле
	```
	<script src="/path/to/script.js"></script>
	```

Как правило, в HTML пишут простые скрипты, сложные выносят в отдельный файл. Обычно писать скрипт в HTML плохая практика, этот метод используется только в крайних случаях.
При подключении посредством файла браузер скачает его только первый раз и в дальнейшем, при правильной настройке сервера, будет брать из своего кеша.


## Порядок загрузки скриптов
Браузер загружает содержимое страницы последовательно. Дойдя до тэга `script` происходит загрузка и выполнение скрипта, после чего продолжается загрузка следующего содержимого. Это называется "синхронной" захрузкой.
Обычно скрипты подключают в самом конце `<body>` чтоб не блокировать загрузку важного содержимого страницы.


## Атрибут `async` (`<script async src='...'`>
При этом атрибуте загрузка внешнего скрипта происходит "асинхронно", то есть доходя до этого тэга происходит паралельная загрузка и обработка этого тэга и переход к следующему.


## Атрибут `defer` (`<script defer src='...'`>
При этом атрибуте загрузка внешнего скрипта происходит также асинхронно, но выполнение происходит уже после готовности страницы, причем с учетом порядка подключаемых с этим атрибутом скриптов.


## 'use strict'
Раньше (до ES5) yовые возможности добавлялись в язык, но старые – никогда не менялись, чтобы не сломать уже существующие сайты. Это привело к тому, что ошибки в самом языке не исправлялись (включая ошибки безопасности).

В ES5 много ошибок языка были исправлены и для того чтоб они учитывались используется директива 'use strict', без неё старые сайты - работают, а с ней в новых сайтах нет ошибок языка и применяются самые последние возможности.

'use strict' ставится только в начале файла или функции.


## Переменные
На странице нужно работать с полученной информацией, ею нужно как-то манипулировать и хранить. Для этого используются переменные (информация в них изменяется. потому и переменная *сущность*) в которые записывается выбранная информация и используется в дальнейшем.

Для объявления (создания) переменной используется ключевое слово `var` (variable - англ. переменная) и уникальное имя переменной. Например: `var message;`.

Можно записать данные (присвоить) в переменную после обьявления (`var message; message = 'Hello';`) или сразу обьявить её с нужным значением (`var message = 'Hello';`).

В дальнейшем переменные используются функциями при обращении к ним по имени:
```
var message = 'Hello';
alert( message ); // Появится окно со значением переменной - Hello
```

Посредством директивы `var` через запятую можно обьявить сразу несколько переменных:
```
var
	user = 'John',
	age = 25,
	message = 'Hello';
```

Изменение переменной происходит при повторном присваивании:
```
var message = 'Hello';
alert( message ); // Появится окно со значением переменной - Hello

message = 'Hi';
alert( message ); // Появится окно новым значением переменной - Hi
```

На имя переменной в JavaScript наложены ограничения.
- имя может состоять из: букв, цифр, символов $ и _
- первый символ не должен быть цифрой
- регистр букв имеет значение
- не английские символы допустимы, но не рекомендуются

Существует список зарезервированных слов, которые нельзя использовать для переменных, так как они используются самим языком, например: `var`, `class`, `return`, `export` и т.д.

В JS принято использовать camelCase при именовании переменных.
Лучше давать переменным осмысленные имена на английском, которые отражают их содержимое или назначение.


## Константа
Проще говоря **константа** – это переменная, которая никогда не меняется.
В JS принято использовать UPPERCASE_UNDER_SCORE при именовании констант.
В ES6 для обьявления константы используется директива `const` которая не позволяет измениять переменную выдавая ошибку.


## Примитивные типы данных
1. `number` - число (целое или десятичное), также есть специальные числовые значения:
	- Infinity - бесконечность (например, при делении на ноль)
	- NaN - не число (при некорректных числовых операциях, например: `"нечисло" * 2`)

2. `string` - строка, обозначается одинарными или двойными кавычками (например: 'Привет', "Слово". Подразумевается текстовая строка, строка без содержимого тоже строка: '')

3. `boolean` - логический тип (булевый), имеет всего два возможных значения: true (истина) и false (ложь)

4. `undefined` - подразумевает отсутствие данных (все переменные имеют изначально это значение, если явно не указанно другое)

5. `null` - подразумевает явное отсутствие данных (например после каких либо операций, например, чтоб было понятно что ничего небыло найдено при поиске и было понятно что поиск выполнился успешно, в противном случае было бы значение `undefined`)


## Обьект `object`
Последний тип данных, не является примитивным, используется для хранения данных в формате { "ключ": значение }, может хранить в себе методы (функции вместо значений), или определяет более сложную сущность (например, описание узла в DOM, или собственный прототип)


## Оператор `typeof`
Возвращает тип аргумента в виде строки.
Два варианта записи:
- как оператор: `typeof x`
- как функция: `typeof(x)`.

Примеры использования:
```
typeof undefined;    // "undefined"
typeof 0;            // "number"
typeof true;         // "boolean"
typeof "foo";        // "string"
typeof {};           // "object"
typeof null;         // "object" (1)
typeof function(){}; // "function" (2)
```

Особенности:
1. `typeof( null ) === 'object'` - официальная ошибка в языке, сохраняется для совместимости, о ней нужно помнить.
2. `typeof( function(){} ) === 'function'` - функции не являются отдельным базовым типом в JS, а подвидом объектов, но на практике удобно определять функцию таким образом.


## Понятия для операторов
**Операнд** – сущность, к которой применяется оператор. (`5 * 2` – оператор умножения с левым и правым операндами).

**Унарный оператор** - оператор, который применяется к одному операнду (унарный минус меняет знак числа на противоположный: `var x = 1; x = -x;`, результат `x = -1`).

**Бинарный оператор** - оператор, который применяется к двум операндам (бинарный минус отнимает от левого операнад, правый: `var a = x - y;`).


## Основные операторы

Приоритет оператора - определяет порядок выполнения опереторов в выражении (см. https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence).

#### Унарный `=` - присваивание, присваевает значение переменной.
```
x = 'asdf';          // x === 'asdf'
x = 2 * 2 + 1;       // x === 5
a = b = c = 2 + 2;   // a === 4, b === 4, c === 4
c = 3 - (a = b + 1); // a === 3, c === 0
```

#### Бинарный `+` - сложение чисел и строк (конкатенация строк). Если хоть один аргумент строка, то и второй преобразуется к строке, все остальные операторы преобразуют к числу.
```
1 + 2 === 3;
'1' + '2' === '12';
1 + '2' === '12';
'1' + 2 === '12';
1 + '' === '1';
```

#### Унарный `+` - преобразование к числу.
```
+1 === 1;
+'1' === 1;
+( 1 + 2 ) === 3;
+( '1' + '2' ) === 12;
+'1' + +'2' === 3;
```

#### Бинарный `%` - взятие остатка, остаток деления левого операнда на правый.
```
5 % 2 // 1
8 % 3 // 2
6 % 3 // 0
```

#### Сокращённая арифметика с присваиванием
Применяется к для операторов `+`, `-`, `*`, `/`, `%` и бинарных `<<`, `>>`, `>>>`, `&`, `|`, `^`
```
var n = 2;
n += 5; // n === 7 (n = n + 5;)
n *= 2; // n === 14 (n = n * 2;)
n -= 4; // n === 10 (n = n - 4;)
```

#### Унарный `++`/`--` - инкремент/декремент, увеличивает или уменьшает значение на единицу, применим только к переменной, имеет префиксную (изменяет и возвращает новое значение) и постфиксную (возвращает текущее значение, после - изменияет) формы;
```
var i = 5;

console.log( i++ ) // 5
console.log( i )   // 6
console.log( i-- ) // 6
console.log( i )   // 5

console.log( ++i ) // 6
console.log( i )   // 6
console.log( --i ) // 5
console.log( i )   // 5
```

#### Запятая `,` - применяется для групирования операций. Обычно используется в составе более сложных конструкций, чтобы сделать несколько действий в одной строке. Например:
```
for ( a = 1, b = 3, c = a * b; a < 10; a++ ) { ... }
```

#### Побитовые операторы
Используются редко, поэтому рассматриваться пока не будут:
- `&`   - AND(и)
- `|`   - OR(или)
- `^`   - XOR(побитовое исключающее или)
- `~`   - NOT(не)
- `<<`  - LEFT SHIFT(левый сдвиг)
- `>>`  - RIGHT SHIFT(правый сдвиг)
- `>>>` - ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями)


## Операторы сравнения

Возвращают всегда логические значения `true`/`false`.
Строки сравниваются побуквенно, символы в юникоде имеют свой код, он и сравнивается.
Если символов много - они поочередно сравниваются друг с другом (лексикографическое сравнение).
При сравнении разных типов данных используется числовое преобразование (значения приводятся к числам).
Строгое сравнение при разных типах данных возвращает `false`.
`null` и `undefined` лучше никогда не сравнивать между собой и остальными типами данных не строго из за особенностей языка (см. примеры), они равны (`==`) друг другу и не равны ничему другому.

`>` - больше
`<` - меньше
`>=` - больше или равно
`<=` - меньше или равно
`==` - равно
`!=` - не равно
`===` - строго равно
`!==` - строго не равно

Примеры:
```
2 > 1;                   // true
2 == 1;                  // false
1 != 1;                  // true

'2' > '14';              // true
+'2' > +'14';            // false
'Б' > 'А';               // true
'а' > 'Я';               // true
'Вася' > 'Ваня';         // true, 'с' > 'н'
'Привет' > 'Прив';       // true, 'е' > ничего

'2' > 1;                 // true, 2 > 1
'01' == 1;               // true, 1 == 1
false == 0;              // true, false становится числом 0
true == 1;               // true, true становится числом 1

null == undefined;       // true, хотя null становится 0, undefined становится NaN
null == null;            // true
undefined == undefined;  // true

null === undefined;      // false
null === null;           // true
undefined === undefined; // true

null > 0;                // false
null == 0;               // false
null >= 0;               // true

undefined > 0;           // false
undefined < 0;           // false
undefined == 0;          // false
```


## Оператор `if`
Оператор `if` вычисляет и преобразует выражение в круглых скобках к логическому типу и если полученный результат это `true` выполняет вложенный блок кода. Дополнительный блок кода `else` вылолнится если результат выражения `false`.
Можно создавать последовательные цепочки условий посредством блоков `else if`.


## Тернарный оператор `?`
Является анологом оператора `if` но при этом может возвращать значение. Имеет три операнда.
```
var x = (age > 14) ? true : false; // условие ? значение_true : значение_false
```


## Логические операторы

`&&` - логическое И, возвращает true, если оба аргумента истинны (запинается на «лжи»)
`||` - логическое ИЛИ, возвращает true, если один из аргументов истинен (запинается на «правде»)
`!`  - логическое НЕ

Логические операторы приводят данные к логическому типу.
Приоритет у `&&` больше, чем у `||`, он выполняется в первую очередь.
`!` можно использовать как короткую форму для приведения данных к логическому типу (`!!"строка"` === true)

Примеры:
```
true || true;   // true
false || true;  // true
true || false;  // true
false || false; // false

true && true;   // true
false && true;  // false
true && false;  // false
false && false; // false

!true;          // false
!0;             // true

false || true || false; // true
false && true && false; // false
```


## Преобразование типов для примитивов

Некоторые или самописные функции сами производят преобразование входных данных.

#### Строковое преобразование
Для явного преобразования к строке используется конструктор `String( value )` или бинарный оператор со строкой в качестве одного из аргументов. Преобразование происходит "как есть": false становится "false", null – "null", undefined – "undefined" и т.д.
```
String( null );    // 'null'
true + 'test';     // 'truetest'
'123' + undefined; // '123undefined'
```

#### Численное преобразование
Для преобразования к числу в явном виде можно вызвать конструктор `Number( value )`, либо, поставить перед выражением унарный плюс `+`.
```
Number( undefined ); // NaN
Number( null );      // 0
Number( true );      // 1
Number( false );     // 0
Number( 'string' );  // NaN
Number( '123' );     // 123
```

#### Преобразование к логическому значению
Для явного преобразования используется двойное логическое отрицание `!!value` или конструктор `Boolean( value )`.
```
Boolean( undefined )       // false
Boolean( null );           // false
Boolean( NaN );            // false
Boolean( 0 );              // false
Boolean( 1 );              // true
Boolean( '' );             // false
Boolean( 'asdf' );         // true
Boolean({ key: 'value' }); // true
```


## Цикл `while`
Цикл повторяется пока условие верно. Изменение условия возможно из теля цикла.
Итерация - повторение цикла.
Условие в круглых скобках интерпритируется как логическое.
```
while ( условие ) {
	// тело цикла
}

var i = 0;
while ( i < 3 ) { // выводит i пока i < 3
	alert( i );
	i++;
}
```

Проверку условия можно поставить под телом цикла, используя специальный синтаксис `do..while`.
Используется редко так как не очень наглядный.
```
do {
  // тело цикла
} while ( условие );
```


## Цикл `for`
```
for ( начало; условие; шаг ) {
  // тело цикла
}
```

Например:
```
for ( var i = 0; i < 3; i++ ) {
  alert( i );
}
```
Здесь:
- начало: `i = 0`
- условие: `i < 3`
- шаг: `i++`
- тело: `alert(i);`, т.е. код внутри фигурных скобок (они не обязательны, если только одна операция)

Цикл выполняется так:
- начало: `i = 0` - выполняется один-единственный раз, при заходе в цикл.
- проверка условия: `i < 3` - проверяется перед каждой итерацией и при входе в цикл, если оно нарушено, то происходит выход.
- выполнение тела: `alert(i);`
- шаг: `i++` - выполняется после тела на каждой итерации, но перед проверкой условия.

Иными словами, поток выполнения
- начало
- если условие → тело → шаг
- если условие → тело → шаг
- … и так далее, пока верно условие.

Точки с запятой `;` обязательно должны присутствовать.


## `break` и `continue`

`break` - позволяет выйти из цикла в любой момент.
`continue` - позволяет перейти на следующую итерацию в любой момент.

Нельзя использовать `break`/`continue` справа от оператора `?`, так как должно возвращаться значение.
Код ниже приведет к ошибке.
```
(i > 5) ? alert(i) : continue;
```


## Метки для `break`/`continue`
Для того чтоб выйти из нескольких уровней цикла можно использовать метки для директив `break`/`continue`.
Метка имеет вид `имя:`, имя должно быть уникальным. Ставится строго перед циклом. Метки не позволяют прыгнуть в произвольное место кода, в JS нет такой возможности.
```
outer: for ( var i = 0; i < 3; i++ ) {
	for ( var j = 0; j < 3; j++ ) {
		if ( ... ) break outer;
	}
}
```


## Конструкция `switch`
Конструкция switch заменяет собой сразу несколько `if`.
Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.
Значение внутри скобок провряется на строгое равенство одному из вариантов (`case` - кейсов).
Если есть подходщий вариант то выполняется его тело до ближфйшего `break`, если нет - выполняется блок `default` до `break` или конца.
Если `default` нет и нет подходящего варианта - ничего не выполнится.
Если `break` нет, то выполнение пойдёт ниже по следующим кейсам, при этом проверки игнорируются, таким образом кейсы групируются.
```
switch( x ) {
	case 'value1': // if ( x === 'value1' )
		// тело варианта
		[break;]
	case 'value2': // if ( x === 'value2' )
		// тело варианта
		[break;]
	default:       // Стандартное действие если нет вариантов
		...
		[break;]
}
```


## Функции
Функции используются чтоб не повторять один и тот же код во многих местах, они являются основными «строительными блоками» программы.

Вначале идет ключевое слово function, после него имя функции, затем список параметров в скобках (параметры могут отсутствовать), тело функции – код, который выполняется при её вызове и возвращаемое значение.
```
function имя ( [параметр], [параметр] ) {
	// тело функции
	[return возвращаемое_значение;]
}
```

Функция может содержать локальные переменные.
Блоки `if/else`, `switch`, `for`, `while`, `do..while` не влияют на область видимости переменных.
```
function test () {
	var tmp = 'Hello'; // локальная переменная
}
```

Функция может обращаться ко внешней переменной и даже изменять её.
```
var tmp = 'Hello'; // внешняя переменная

function showMessage () {
	alert( tmp ); // использование внешней переменной
	tmp = 'Hi'; // изменение внешней переменной
}

showMessage(); // вызов функции
```

Параметры копируются в локальные переменные функции.
```
function showMessage ( message ) {
	alert( message );
}

showMessage( 'HI' ); // выведет 'HI'
```

Если параметр не передан при вызове – он считается равным `undefined`.
```
function showMessage ( message ) {
	alert( message );
}

showMessage(); // выведет 'undefined'
```

Функция может возвратить результат. Его можно сразу записать в переменную.
```
function sum ( a ) {
	return a + b;
}

var result = showMessage( 1, 3 ); // вернет 4 которое запишется в переменную result
alert( result ); // выведет 4
```

Директив `result` может быть несколько. Также она может использоваться без значения, чтобы прекратить выполнение и выйти из функции (тогда она вернет `undefined`).
```
function sum ( a ) {
	if ( !a ) return;
	else return a + a;
}
```

В JS функция является значением, таким же как строка или число.
Функцию можно скопировать в другую переменную.
```
function sayHi() {
	alert( 'Привет' );
}

var otherHi = sayHi;
otherHi(); // выведет 'Привет'
sayHi();   // тоже выведет 'Привет'
```

Можно и просто вывести текст функции (функция вызывается (выполняется) только если переданны параметры или записаны скобки)
```
function sayHi() {
	alert( 'Привет' );
}

// выведет 'Привет'
sayHi();

// выведет код функции 'function sayHi() { alert( 'Привет' ); }'
alert( sayHi );

// выведет сначала 'Привет', затем выведет 'undefined' так как функция ничего не возвращает
alert( sayHi() );
```

#### Объявление Function Expression
"Классическое"" объявление функции, называется в спецификации языка "Function Declaration".

Есть альтернативный синтаксис для объявления функции, который ещё более наглядно показывает, что функция – это разновидность значения переменной.
```
var имяФункции = function( параметры ) {
	// тело функции
};
```

Несмотря на разный вид, две эти записи делают одно и то же.
Обычно разная запись используется:
- Function Declaration – в основном потоке кода
- Function Expression – в контексте какого-либо выражения, например присваивания

Основное отличие между ними:
- Function Declaration - создаются интерпретатором до выполнения кода (можно вызвать до объявления)
- Function Expression – создаются интерпретатором по мере выполнения кода

#### Анонимные функции
Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.
```
function ask( question, yes, no ) {
	if ( confirm( question ) ) {
		yes(); // вызов первой переданной анонимной функции которая передана как параметр 'yes'
	} else {
		no(); // вызов первой второй анонимной функции которая передана как параметр 'no'
	}
}

ask(                                               // выше обьявленная функция 'ask'
	"Вы согласны?",
	function() { alert("Вы согласились."); },        // первая анонимная функция
	function() { alert("Вы отменили выполнение."); } // вторая анонимная функция
);
```

#### Конструктор функции
Позволяет создавать функцию полностью "на лету" из строки
```
var sum = new Function('a,b', ' return a+b; ');
```
где:
- `params` - параметры функции через запятую в виде строки
- `code` - код функции в виде строки

Таким образом можно конструировать функцию, код которой неизвестен на момент написания программы, но строка с ним генерируется или подгружается динамически во время её выполнения.

#### Рекурсия
В теле функции могут быть вызваны другие функции для выполнения подзадач.
**Рекурсия** - это частный случай подвызова, когда функция вызывает сама себя.
**Базис рекурсии** - значение, на котором рекурсия заканчивается.
**Глубина рекурсии** - общее количество вложенных вызовов.
```
function doTest( value ) {
	if ( value ) {
		alert( value );
		doTest( --value ); // здесь функция рекурсивно вызывает сама себя
	}
}

doTest( 5 );
```

В примере выше:
- базис рекурсии - 1
- глубина рекурсии - 5

Максимальная глубина рекурсии в браузерах ограничена, точно можно рассчитывать на 10000 вложенных вызовов, но некоторые интерпретаторы допускают и больше.

#### TODO Контекст выполнения, стек

#### Именованные функциональные выражения (Named Function Expression, NFE)
Имя функционального выражения доступно только изнутри самой функции.
Как правило, имя NFE используется чтоб позволить изнутри функции вызвать саму себя.
Имя NFE нельзя перезаписать.
```
var testFunction = function sayHi(...) {
	// тело функции
	alert( sayHi ); // изнутри функции - видно (выведет код функции)

	sayHi = 'тест'; // попытка перезаписи
	alert( sayHi ); // function... (перезапись не удалась, в режиме use strict код выдал бы ошибку)
};

alert( sayHi ); // снаружи - не видно (ошибка: undefined variable 'sayHi')
```



# Д.З.
Полностью прочесть раздел ['Основы JavaScript'](https://learn.javascript.ru/first-steps).
Выполнить из него все задачи.

## Формат решения задач
Для каждой задачи создать файл с разметкой, файлы нумеровать и именовать по задаче, в `<title>` указать номер и имя задачи, в `<script>` - решение:
```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Номер и имя задачи</title>
</head>
<body>
	<script>
		// Решение
	</script>
</body>
</html>
```
